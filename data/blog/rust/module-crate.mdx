---
title: '모듈(Module)과 크레이트(Crate)'
date: 2024-12-30 21:00:00 +0900
tags: ['RUST', 'LANGUAGE']
draft: true
summary: '러스트의 모듈과 크레이트에 대한 설명과 활용법'
layout: PostSimple
---

Rust는 모듈(Module)과 크레이트(Crate)라는 두 가지 주요 개념을 통해 코드를 조직화하고 관리한다. 
모듈과 크레이트 각각의 개념과 활용법에 대해 알아보자.

먼저, 모든 Rust 프로그램이나 라이브러리(Library)는 하나의 크레이트이다.
그리고, 모든 크레이트는 모듈의 계층구조로 이루어져 있다.
동시에, 모든 크레이트에는 최상위 루트 모듈이 있다.

모듈에는 전역변수, 함수, struct, trait 또는 다른 모듈까지도 포함될 수 있다.

모듈의 트리구조는 모두 직접 코드로 작성해야 한다.

프로그램은 `main.rs` 파일에 루트 모듈이 있고, 라이브러리는 `lib.rs` 파일에 루트 모듈이 있다.

## 모듈 불러오기

```Rust
use std::f64::consts::PI;

fn main() {
    println!("PI: {}", PI);
}
```

## 모듈 여러개의 항목 참조하기

```Rust
use std::f64::consts::{PI, E};

fn main() {
    println!("PI: {}", PI);
    println!("E: {}", E);
}
```

## 모듈 작성하기

Rust에서 모듈을 선언하는 방법은 2가지가 있다.

1. `foo.rs`라는 이름의 파일
2. `mod` 키워드를 사용하여 모듈을 선언하는 방법

한 모듈은 다른 모듈에 의존할 수 있다.
모듈과 하위모듈 사이에 관계를 지어주려면, 부모 모듈에 다음과 같은 코드를 작성한다.

```Rust
mod foo;
```

위 선언은 `foo.rs` 파일이나 `foo/mod.rs` 파일을 찾아 이 scope 내의 `foo` 모듈안의 내용물을 삽입한다.


## Prelude
`use`로 가져오지 않아도 어디서나 `Vec`, `String`, `Option`, `Result` 등을 사용할 수 있다.
Rust의 standard 라이브러리에서는 `std::prelude::*`로 내보내기 된 모든 것들이 어디에서든 자동을 사용 가능하다.